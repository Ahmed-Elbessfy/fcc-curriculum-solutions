{"index.js":"// Functional Programming: Introduction to Currying and Partial Application\n// The arity of a function is the number of arguments it requires. Currying a function means to convert a function of N arity into N functions of arity 1.\n\n// In other words, it restructures a function so it takes one argument, then returns another function that takes the next argument, and so on.\n\n// Here's an example:\n\n// //Un-curried function\n// function unCurried(x, y) {\n//   return x + y;\n// }\n\n// //Curried function\n// function curried(x) {\n//   return function(y) {\n//     return x + y;\n//   }\n// }\n// curried(1)(2) // Returns 3\n// This is useful in your program if you can't supply all the arguments to a function at one time. You can save each function call into a variable, which will hold the returned function reference that takes the next argument when it's available. Here's an example using the curried function in the example above:\n\n// // Call a curried function in parts:\n// var funcForY = curried(1);\n// console.log(funcForY(2)); // Prints 3\n// Similarly, partial application can be described as applying a few arguments to a function at a time and returning another function that is applied to more arguments.\n\n// Here's an example:\n\n// //Impartial function\n// function impartial(x, y, z) {\n//   return x + y + z;\n// }\n// var partialFn = impartial.bind(this, 1, 2);\n// partialFn(10); // Returns 13\n\n// Fill in the body of the add function so it uses currying to add parameters x, y, and z.\n\nfunction add(x) {\n  // Add your code below this line\n  return (y) => {\n    return (z) => x+y+z;\n  }\n  \n  // Add your code above this line\n}\nadd(10)(20)(30);"}